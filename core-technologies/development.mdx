---
title: "Validation, Data Binding, and Type Conversion"
---

## Spring’s Validator Interface

Spring cung cấp `Validator` interface để validate objects. Nếu quá trình validate xảy ra error, `Errors` object sẽ chứa thông tin error đó.

Để xử lý validate cho class, có thể cung cấp class implement `Validator` interface. Handle validate business logic code thông qua method `validate` và `supports(Class)`. Spring cung cấp sẵn `ValidationUtils` helper class có các method hữu ích trong việc validate.

Nếu có một class phức tạp mà bên trong có những object phụ thuộc khác thì cách tốt nhất là nên viết các class `Validator` riêng cho từng object. Ví dụ trong `Customer` có field là `Address` object, ta nên viết `AddressValidator` cho `Address` object, và một `CustomerValidator` cho `Customer`. Trong `CustomerValidator` sẽ tái sử dụng business validate của `AddressValidator` bằng cách inject `AddressValidator` vào `CustomerValidator` như sau:

```java
public class CustomerValidator implements Validator {

	private final Validator addressValidator;

	public CustomerValidator(Validator addressValidator) {
		if (addressValidator == null) {
			throw new IllegalArgumentException("The supplied [Validator] is " +
				"required and must not be null.");
		}
		if (!addressValidator.supports(Address.class)) {
			throw new IllegalArgumentException("The supplied [Validator] must " +
				"support the validation of [Address] instances.");
		}
		this.addressValidator = addressValidator;
	}

	/**
	 * This Validator validates Customer instances, and any subclasses of Customer too
	 */
	public boolean supports(Class clazz) {
		return Customer.class.isAssignableFrom(clazz);
	}

	public void validate(Object target, Errors errors) {
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
		Customer customer = (Customer) target;
		try {
			errors.pushNestedPath("address");
			ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
		} finally {
			errors.popNestedPath();
		}
	}
}
```

## Data Binding

### `Data Binding` là gì?

`Data Binding` là quá trình ánh xạ (mapping) dữ liệu từ các nguồn bên ngoài (như tham số truy vấn trên URL, dữ liệu từ Form HTML, hoặc JSON) vào các thuộc tính của một đối tượng Java.

### Cách thức hoạt động của `Data Binding`

Quy trình diễn ra cơ bản qua các bước sau:

1. **Tiếp nhận Request:** Người dùng gửi một yêu cầu (GET hoặc POST) kèm dữ liệu.
2. **Khởi tạo DataBinder:** Spring tạo ra một đối tượng `WebDataBinder`.
3. **Chuyển đổi kiểu dữ liệu (Conversion):** Đây là bước quan trọng nhất. Vì dữ liệu từ HTTP luôn là chuỗi (String), Spring cần chuyển chúng sang đúng kiểu dữ liệu của thuộc tính (như `int`, `boolean`, `Date`, hoặc các Object phức tạp).
4. **Gán giá trị (Populating):** Sau khi chuyển đổi thành công, giá trị được gán vào các trường của POJO.
5. **Kiểm tra lỗi (BindingResult):** Nếu có lỗi (ví dụ: nhập chữ vào trường số), Spring sẽ lưu lỗi vào đối tượng `BindingResult` thay vì làm ứng dụng bị "sập".

## Java Bean Validation

**Java Bean Validation** là một đặc tả (specification) của Java (hiện nay là **Jakarta Bean Validation**) cho phép bạn định nghĩa các quy tắc kiểm tra dữ liệu bằng cách sử dụng các **Annotation** ngay trên các trường (fields) của class.

| Loại     | Annotation     | Ý nghĩa     |
| --------- | --------- | --------- |
| Kiểm tra Null | `@NotNull`, `@NotEmpty`, `@NotBlank` | Kiểm tra không null, không rỗng, hoặc không chỉ chứa khoảng trắng. |
| Kích thước | `@Size(min=, max=)`, `@Min`, `@Max` | Giới hạn độ dài chuỗi, số lượng phần tử mảng hoặc giá trị số. |
| Định dạng | `@Email`, `@Pattern(regexp=)` | Kiểm tra email hợp lệ hoặc khớp với biểu thức chính quy (Regex). |
| Logic | `@AssertTrue`, `@AssertFalse` | Kiểm tra giá trị boolean. |
| Thời gian | `@Past`, `@Future` | Kiểm tra ngày tháng phải ở quá khứ hoặc tương lai. |